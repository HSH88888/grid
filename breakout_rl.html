
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Q-Learning ë²½ëŒê¹¨ê¸°</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
display: flex;
flex-direction: column;
align-items: center;
padding: 20px;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
}

.container {
background: white;
padding: 30px;
border-radius: 15px;
box-shadow: 0 10px 40px rgba(0,0,0,0.3);
max-width: 900px;
}

h1 {
color: #333;
text-align: center;
margin-bottom: 10px;
}

.subtitle {
text-align: center;
color: #666;
margin-bottom: 20px;
font-size: 14px;
}

.game-area {
display: flex;
gap: 20px;
margin: 20px 0;
flex-wrap: wrap;
justify-content: center;
}

#gameCanvas {
border: 3px solid #333;
border-radius: 8px;
box-shadow: 0 4px 15px rgba(0,0,0,0.2);
background: #000;
}

.controls {
display: flex;
gap: 10px;
justify-content: center;
margin: 20px 0;
flex-wrap: wrap;
}

button {
padding: 12px 24px;
font-size: 16px;
cursor: pointer;
border: none;
border-radius: 6px;
background: #667eea;
color: white;
transition: all 0.3s;
font-weight: 600;
}

button:hover {
background: #5568d3;
transform: translateY(-2px);
}

button:disabled {
background: #ccc;
cursor: not-allowed;
transform: none;
}

button.active {
background: #4CAF50;
}

.stats {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
gap: 15px;
margin: 20px 0;
}

.stat-box {
background: #f5f5f5;
padding: 15px;
border-radius: 8px;
text-align: center;
}

.stat-label {
color: #666;
font-size: 14px;
margin-bottom: 5px;
}

.stat-value {
color: #333;
font-size: 24px;
font-weight: bold;
}

.info {
background: #e3f2fd;
padding: 15px;
border-radius: 8px;
margin: 15px 0;
border-left: 4px solid #2196F3;
font-size: 14px;
line-height: 1.6;
}

.q-info {
background: #fff3cd;
padding: 15px;
border-radius: 8px;
margin: 15px 0;
border-left: 4px solid #FF9800;
font-size: 13px;
}

.speed-control {
display: flex;
align-items: center;
gap: 10px;
justify-content: center;
margin: 15px 0;
}

input[type="range"] {
width: 200px;
}

@media (max-width: 768px) {
.container {
padding: 15px;
}
#gameCanvas {
width: 100%;
max-width: 400px;
height: auto;
}
}
</style>
</head>
<body>
<div class="container">
<h1>ğŸ® Q-Learning ë²½ëŒê¹¨ê¸°</h1>
<p class="subtitle">ê°•í™”í•™ìŠµìœ¼ë¡œ AIê°€ ë²½ëŒê¹¨ê¸°ë¥¼ ìŠ¤ìŠ¤ë¡œ í•™ìŠµí•©ë‹ˆë‹¤</p>

<div class="game-area">
<canvas id="gameCanvas" width="400" height="500"></canvas>
</div>

<div class="stats">
<div class="stat-box">
<div class="stat-label">ì—í”¼ì†Œë“œ</div>
<div class="stat-value" id="episode">0</div>
</div>
<div class="stat-box">
<div class="stat-label">í˜„ì¬ ì ìˆ˜</div>
<div class="stat-value" id="score">0</div>
</div>
<div class="stat-box">
<div class="stat-label">í‰ê·  ì ìˆ˜</div>
<div class="stat-value" id="avgScore">0</div>
</div>
<div class="stat-box">
<div class="stat-label">ìµœê³  ì ìˆ˜</div>
<div class="stat-value" id="maxScore">0</div>
</div>
<div class="stat-box">
<div class="stat-label">ì„±ê³µë¥ </div>
<div class="stat-value" id="successRate">0%</div>
</div>
<div class="stat-box">
<div class="stat-label">Q-í…Œì´ë¸”</div>
<div class="stat-value" id="qTableSize">0</div>
</div>
</div>

<div class="speed-control">
<label for="speed">í•™ìŠµ ì†ë„:</label>
<input type="range" id="speed" min="1" max="10" value="5">
<span id="speedValue">5x</span>
</div>

<div class="controls">
<button id="trainBtn" onclick="startTraining()">ğŸ“ í•™ìŠµ ì‹œì‘</button>
<button id="stopBtn" onclick="stopTraining()" disabled>â¸ï¸ ì •ì§€</button>
<button id="resetBtn" onclick="resetLearning()">ğŸ”„ ì´ˆê¸°í™”</button>
<button id="testBtn" onclick="testAgent()">ğŸ¯ í…ŒìŠ¤íŠ¸ (íƒí—˜ ë„ê¸°)</button>
<button id="qBtn" onclick="toggleQDisplay()">ğŸ“Š Qê°’ í‘œì‹œ</button>
</div>

<div class="q-info">
<strong>ğŸ“ˆ Q-Learning ìƒíƒœ ë‹¨ìˆœí™”:</strong><br>
â€¢ <strong>ìƒíƒœ</strong>: (ê³µ X ìœ„ì¹˜ 10êµ¬ê°„) Ã— (ê³µ ë°©í–¥ 2ê°€ì§€) Ã— (íŒ¨ë“¤ ìœ„ì¹˜ 10êµ¬ê°„) = 200ê°€ì§€<br>
â€¢ <strong>í–‰ë™</strong>: ì™¼ìª½(-1), ì •ì§€(0), ì˜¤ë¥¸ìª½(+1) = 3ê°€ì§€<br>
â€¢ <strong>Q-í…Œì´ë¸” í¬ê¸°</strong>: 200 Ã— 3 = 600ê°œ (ê´€ë¦¬ ê°€ëŠ¥!)<br>
â€¢ <strong>ë³´ìƒ</strong>: ë²½ëŒ ê¹¨ê¸° +10, ê³µ ë°›ê¸° +5, ê³µ ë†“ì¹¨ -100
</div>

<div class="info">
<strong>ğŸ“š í•™ìŠµ ì›ë¦¬:</strong><br>
â€¢ AIê°€ ê³µì˜ ìœ„ì¹˜ì™€ ë°©í–¥ì„ ë³´ê³  íŒ¨ë“¤ì„ ì–´ë””ë¡œ ì›€ì§ì¼ì§€ í•™ìŠµí•©ë‹ˆë‹¤<br>
â€¢ ì²˜ìŒì—” ë¬´ì‘ìœ„ë¡œ ì›€ì§ì´ë‹¤ê°€ ì ì  ê³µì„ ë°›ëŠ” ë²•ì„ ë°°ì›ë‹ˆë‹¤<br>
â€¢ 50 ì—í”¼ì†Œë“œ ì •ë„ë©´ ê¸°ë³¸ì ì¸ ê³µ ë°›ê¸°ë¥¼ í•™ìŠµí•©ë‹ˆë‹¤<br>
â€¢ <strong>í•™ìŠµë¥ (Î±)</strong>: 0.3, <strong>í• ì¸ìœ¨(Î³)</strong>: 0.95, <strong>íƒí—˜ìœ¨(Îµ)</strong>: 0.1
</div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ê²Œì„ ì„¤ì •
const PADDLE_WIDTH = 80;
const PADDLE_HEIGHT = 10;
const BALL_RADIUS = 6;
const BRICK_ROWS = 5;
const BRICK_COLS = 8;
const BRICK_WIDTH = 45;
const BRICK_HEIGHT = 15;
const BRICK_PADDING = 5;
const BRICK_OFFSET_TOP = 50;
const BRICK_OFFSET_LEFT = 10;

// Q-Learning ì„¤ì •
const ALPHA = 0.3;  // í•™ìŠµë¥ 
const GAMMA = 0.95; // í• ì¸ìœ¨
let EPSILON = 0.1;  // íƒí—˜ìœ¨
const X_ZONES = 10;
const PADDLE_ZONES = 10;
const ACTIONS = [-1, 0, 1]; // ì™¼ìª½, ì •ì§€, ì˜¤ë¥¸ìª½

// ê²Œì„ ìƒíƒœ
let paddle = { x: canvas.width / 2 - PADDLE_WIDTH / 2, y: canvas.height - 30, dx: 0 };
let ball = { x: canvas.width / 2, y: canvas.height - 50, dx: 3, dy: -3 };
let bricks = [];
let score = 0;
let lives = 3;

// í•™ìŠµ ìƒíƒœ
let qTable = {};
let episode = 0;
let totalScore = 0;
let maxScore = 0;
let successCount = 0;
let isTraining = false;
let showQ = false;
let gameInterval = null;
let currentState = null;
let currentAction = null;

// ë²½ëŒ ì´ˆê¸°í™”
function initBricks() {
bricks = [];
for (let row = 0; row < BRICK_ROWS; row++) {
bricks[row] = [];
for (let col = 0; col < BRICK_COLS; col++) {
bricks[row][col] = { x: 0, y: 0, status: 1 };
}
}
}

// ìƒíƒœ í‚¤ ìƒì„±
function getStateKey(ballX, ballDX, paddleX) {
const ballZone = Math.floor(ballX / (canvas.width / X_ZONES));
const ballDir = ballDX > 0 ? 1 : 0; // ì˜¤ë¥¸ìª½:1, ì™¼ìª½:0
const paddleZone = Math.floor(paddleX / (canvas.width / PADDLE_ZONES));
return `${ballZone}-${ballDir}-${paddleZone}`;
}

// Qê°’ ê°€ì ¸ì˜¤ê¸°
function getQValue(state, action) {
const key = `${state}-${action}`;
return qTable[key] || 0;
}

// Qê°’ ì„¤ì •
function setQValue(state, action, value) {
const key = `${state}-${action}`;
qTable[key] = value;
}

// í–‰ë™ ì„ íƒ (Îµ-greedy)
function chooseAction(state) {
if (Math.random() < EPSILON) {
return ACTIONS[Math.floor(Math.random() * ACTIONS.length)];
}

let bestAction = ACTIONS[0];
let bestValue = getQValue(state, bestAction);

for (let action of ACTIONS) {
const value = getQValue(state, action);
if (value > bestValue) {
bestValue = value;
bestAction = action;
}
}
return bestAction;
}

// Qê°’ ì—…ë°ì´íŠ¸
function updateQValue(state, action, reward, nextState) {
const currentQ = getQValue(state, action);

let maxNextQ = -Infinity;
for (let nextAction of ACTIONS) {
const q = getQValue(nextState, nextAction);
if (q > maxNextQ) maxNextQ = q;
}

const newQ = currentQ + ALPHA * (reward + GAMMA * maxNextQ - currentQ);
setQValue(state, action, newQ);
}

// ë²½ëŒ ê·¸ë¦¬ê¸°
function drawBricks() {
for (let row = 0; row < BRICK_ROWS; row++) {
for (let col = 0; col < BRICK_COLS; col++) {
if (bricks[row][col].status === 1) {
const brickX = col * (BRICK_WIDTH + BRICK_PADDING) + BRICK_OFFSET_LEFT;
const brickY = row * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_OFFSET_TOP;
bricks[row][col].x = brickX;
bricks[row][col].y = brickY;

ctx.fillStyle = '#4CAF50';
ctx.fillRect(brickX, brickY, BRICK_WIDTH, BRICK_HEIGHT);
ctx.strokeStyle = '#fff';
ctx.strokeRect(brickX, brickY, BRICK_WIDTH, BRICK_HEIGHT);
}
}
}
}

// íŒ¨ë“¤ ê·¸ë¦¬ê¸°
function drawPaddle() {
ctx.fillStyle = '#2196F3';
ctx.fillRect(paddle.x, paddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);
}

// ê³µ ê·¸ë¦¬ê¸°
function drawBall() {
ctx.beginPath();
ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
ctx.fillStyle = '#FFD700';
ctx.fill();
ctx.closePath();
}

// Qê°’ í‘œì‹œ
function drawQValues() {
if (!showQ) return;

const state = getStateKey(ball.x, ball.dx, paddle.x);
const qLeft = getQValue(state, -1);
const qStay = getQValue(state, 0);
const qRight = getQValue(state, 1);

ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
ctx.fillRect(10, canvas.height - 80, 150, 70);
ctx.fillStyle = '#333';
ctx.font = '12px Arial';
ctx.fillText(`Qê°’ (í˜„ì¬ ìƒíƒœ):`, 20, canvas.height - 65);
ctx.fillText(`â† ì™¼ìª½: ${qLeft.toFixed(1)}`, 20, canvas.height - 50);
ctx.fillText(`â–  ì •ì§€: ${qStay.toFixed(1)}`, 20, canvas.height - 35);
ctx.fillText(`â†’ ì˜¤ë¥¸ìª½: ${qRight.toFixed(1)}`, 20, canvas.height - 20);
}

// ì¶©ëŒ ê°ì§€
function collisionDetection() {
let reward = -0.1; // ìŠ¤í… í˜ë„í‹°

for (let row = 0; row < BRICK_ROWS; row++) {
for (let col = 0; col < BRICK_COLS; col++) {
const brick = bricks[row][col];
if (brick.status === 1) {
if (ball.x > brick.x && ball.x < brick.x + BRICK_WIDTH &&
ball.y > brick.y && ball.y < brick.y + BRICK_HEIGHT) {
ball.dy = -ball.dy;
brick.status = 0;
score += 10;
reward += 10; // ë²½ëŒ ê¹¨ê¸° ë³´ìƒ
}
}
}
}

return reward;
}

// ê²Œì„ ê·¸ë¦¬ê¸°
function draw() {
ctx.fillStyle = '#000';
ctx.fillRect(0, 0, canvas.width, canvas.height);

drawBricks();
drawPaddle();
drawBall();
drawQValues();

// ì ìˆ˜ í‘œì‹œ
ctx.fillStyle = '#fff';
ctx.font = '16px Arial';
ctx.fillText(`ì ìˆ˜: ${score}`, 10, 20);
ctx.fillText(`ì—í”¼ì†Œë“œ: ${episode}`, 10, 40);
}

// ê²Œì„ ì—…ë°ì´íŠ¸
function update() {
const state = getStateKey(ball.x, ball.dx, paddle.x);
const action = chooseAction(state);

// íŒ¨ë“¤ ì´ë™
paddle.dx = action * 8;
paddle.x += paddle.dx;

// íŒ¨ë“¤ ê²½ê³„
if (paddle.x < 0) paddle.x = 0;
if (paddle.x + PADDLE_WIDTH > canvas.width) paddle.x = canvas.width - PADDLE_WIDTH;

// ê³µ ì´ë™
ball.x += ball.dx;
ball.y += ball.dy;

// ë²½ ì¶©ëŒ
if (ball.x + BALL_RADIUS > canvas.width || ball.x - BALL_RADIUS < 0) {
ball.dx = -ball.dx;
}
if (ball.y - BALL_RADIUS < 0) {
ball.dy = -ball.dy;
}

// ë²½ëŒ ì¶©ëŒ ë° ë³´ìƒ
let reward = collisionDetection();

// íŒ¨ë“¤ ì¶©ëŒ
if (ball.y + BALL_RADIUS > paddle.y && 
ball.x > paddle.x && 
ball.x < paddle.x + PADDLE_WIDTH &&
ball.dy > 0) {
ball.dy = -ball.dy;
reward += 5; // ê³µ ë°›ê¸° ë³´ìƒ
}

// ê³µ ë†“ì¹¨
if (ball.y + BALL_RADIUS > canvas.height) {
reward = -100; // í° í˜ë„í‹°
const nextState = getStateKey(ball.x, ball.dx, paddle.x);
updateQValue(state, action, reward, nextState);

lives--;
if (lives <= 0) {
endEpisode();
return false;
}
resetBall();
return true;
}

// ëª¨ë“  ë²½ëŒ ê¹¨ê¸°
if (bricks.every(row => row.every(brick => brick.status === 0))) {
reward += 100; // ì™„ë£Œ ë³´ë„ˆìŠ¤
successCount++;
const nextState = getStateKey(ball.x, ball.dx, paddle.x);
updateQValue(state, action, reward, nextState);
endEpisode();
return false;
}

// Qê°’ ì—…ë°ì´íŠ¸
const nextState = getStateKey(ball.x, ball.dx, paddle.x);
updateQValue(state, action, reward, nextState);

return true;
}

// ê³µ ë¦¬ì…‹
function resetBall() {
ball.x = canvas.width / 2;
ball.y = canvas.height - 50;
ball.dx = (Math.random() > 0.5 ? 1 : -1) * 3;
ball.dy = -3;
}

// ê²Œì„ ë£¨í”„
function gameLoop() {
draw();
if (isTraining) {
const speed = parseInt(document.getElementById('speed').value);
for (let i = 0; i < speed; i++) {
if (!update()) break;
}
updateStats();
}
}

// ì—í”¼ì†Œë“œ ì¢…ë£Œ
function endEpisode() {
episode++;
totalScore += score;
maxScore = Math.max(maxScore, score);
updateStats();

if (isTraining) {
setTimeout(() => {
initGame();
}, 200);
}
}

// ê²Œì„ ì´ˆê¸°í™”
function initGame() {
initBricks();
paddle.x = canvas.width / 2 - PADDLE_WIDTH / 2;
resetBall();
score = 0;
lives = 3;
}

// í†µê³„ ì—…ë°ì´íŠ¸
function updateStats() {
document.getElementById('episode').textContent = episode;
document.getElementById('score').textContent = score;
document.getElementById('avgScore').textContent = episode > 0 ? Math.round(totalScore / episode) : 0;
document.getElementById('maxScore').textContent = maxScore;
const successRate = episode > 0 ? Math.round((successCount / episode) * 100) : 0;
document.getElementById('successRate').textContent = successRate + '%';
document.getElementById('qTableSize').textContent = Object.keys(qTable).length;
}

// í•™ìŠµ ì‹œì‘
function startTraining() {
isTraining = true;
EPSILON = 0.1;
document.getElementById('trainBtn').disabled = true;
document.getElementById('stopBtn').disabled = false;
document.getElementById('testBtn').disabled = true;

if (!gameInterval) {
initGame();
gameInterval = setInterval(gameLoop, 1000 / 60);
}
}

// í•™ìŠµ ì •ì§€
function stopTraining() {
isTraining = false;
document.getElementById('trainBtn').disabled = false;
document.getElementById('stopBtn').disabled = true;
document.getElementById('testBtn').disabled = false;
}

// í•™ìŠµ ì´ˆê¸°í™”
function resetLearning() {
stopTraining();
qTable = {};
episode = 0;
totalScore = 0;
maxScore = 0;
successCount = 0;
initGame();
updateStats();
}

// í…ŒìŠ¤íŠ¸ ëª¨ë“œ
function testAgent() {
stopTraining();
EPSILON = 0; // íƒí—˜ ë„ê¸°
isTraining = true;
document.getElementById('trainBtn').disabled = true;
document.getElementById('testBtn').disabled = true;

if (!gameInterval) {
initGame();
gameInterval = setInterval(gameLoop, 1000 / 60);
}

setTimeout(() => {
isTraining = false;
EPSILON = 0.1;
document.getElementById('trainBtn').disabled = false;
document.getElementById('testBtn').disabled = false;
}, 30000); // 30ì´ˆ í…ŒìŠ¤íŠ¸
}

// Qê°’ í‘œì‹œ í† ê¸€
function toggleQDisplay() {
showQ = !showQ;
const btn = document.getElementById('qBtn');
if (showQ) {
btn.classList.add('active');
btn.textContent = 'ğŸ“Š Qê°’âœ“';
} else {
btn.classList.remove('active');
btn.textContent = 'ğŸ“Š Qê°’';
}
}

// ì†ë„ ì¡°ì ˆ
document.getElementById('speed').addEventListener('input', (e) => {
document.getElementById('speedValue').textContent = e.target.value + 'x';
});

// ì´ˆê¸°í™”
initGame();
updateStats();
</script>
</body>
</html>
