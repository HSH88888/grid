
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Q-Learning ë²½ëŒê¹¨ê¸°</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
display: flex;
flex-direction: column;
align-items: center;
padding: 20px;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
}

.container {
background: white;
padding: 30px;
border-radius: 15px;
box-shadow: 0 10px 40px rgba(0,0,0,0.3);
max-width: 900px;
}

h1 {
color: #333;
text-align: center;
margin-bottom: 10px;
}

.subtitle {
text-align: center;
color: #666;
margin-bottom: 20px;
font-size: 14px;
}

.game-area {
display: flex;
gap: 20px;
margin: 20px 0;
flex-wrap: wrap;
justify-content: center;
}

#gameCanvas {
border: 3px solid #333;
border-radius: 8px;
box-shadow: 0 4px 15px rgba(0,0,0,0.2);
background: #000;
}

.settings {
background: #f5f5f5;
padding: 15px;
border-radius: 8px;
margin: 15px 0;
}

.setting-group {
margin-bottom: 15px;
}

.setting-group:last-child {
margin-bottom: 0;
}

.setting-group label {
display: block;
color: #333;
font-size: 14px;
font-weight: 600;
margin-bottom: 8px;
}

.setting-row {
display: flex;
gap: 10px;
align-items: center;
flex-wrap: wrap;
}

.setting-row input[type="range"] {
flex: 1;
min-width: 150px;
}

.setting-row span {
min-width: 60px;
color: #667eea;
font-weight: bold;
}

select, input[type="number"] {
padding: 8px;
border-radius: 4px;
border: 1px solid #ddd;
font-size: 14px;
}

.preset-buttons {
display: grid;
grid-template-columns: repeat(3, 1fr);
gap: 8px;
margin-top: 8px;
}

.preset-buttons button {
padding: 8px 12px;
font-size: 13px;
}

.controls {
display: flex;
gap: 10px;
justify-content: center;
margin: 20px 0;
flex-wrap: wrap;
}

button {
padding: 12px 24px;
font-size: 16px;
cursor: pointer;
border: none;
border-radius: 6px;
background: #667eea;
color: white;
transition: all 0.3s;
font-weight: 600;
}

button:hover {
background: #5568d3;
transform: translateY(-2px);
}

button:disabled {
background: #ccc;
cursor: not-allowed;
transform: none;
}

button.active {
background: #4CAF50;
}

.stats {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
gap: 15px;
margin: 20px 0;
}

.stat-box {
background: #f5f5f5;
padding: 15px;
border-radius: 8px;
text-align: center;
}

.stat-label {
color: #666;
font-size: 14px;
margin-bottom: 5px;
}

.stat-value {
color: #333;
font-size: 24px;
font-weight: bold;
}

.info {
background: #e3f2fd;
padding: 15px;
border-radius: 8px;
margin: 15px 0;
border-left: 4px solid #2196F3;
font-size: 14px;
line-height: 1.6;
}

.q-info {
background: #fff3cd;
padding: 15px;
border-radius: 8px;
margin: 15px 0;
border-left: 4px solid #FF9800;
font-size: 13px;
}

.speed-control {
display: flex;
align-items: center;
gap: 10px;
justify-content: center;
margin: 15px 0;
}

input[type="range"] {
width: 200px;
}

@media (max-width: 768px) {
.container {
padding: 15px;
}
#gameCanvas {
width: 100%;
max-width: 400px;
height: auto;
}
}
</style>
</head>
<body>
<div class="container">
<h1>ğŸ® Q-Learning ë²½ëŒê¹¨ê¸°</h1>
<p class="subtitle">ê°•í™”í•™ìŠµìœ¼ë¡œ AIê°€ ë²½ëŒê¹¨ê¸°ë¥¼ ìŠ¤ìŠ¤ë¡œ í•™ìŠµí•©ë‹ˆë‹¤</p>

<div class="settings">
<div class="setting-group">
<label>ğŸ§± ë²½ëŒ ì„¤ì •</label>
<div class="setting-row">
<span>ê°€ë¡œ:</span>
<input type="range" id="brickCols" min="3" max="12" value="8" 
       oninput="document.getElementById('colsValue').textContent = this.value">
<span id="colsValue">8</span>
</div>
<div class="setting-row">
<span>ì„¸ë¡œ:</span>
<input type="range" id="brickRows" min="2" max="8" value="5" 
       oninput="document.getElementById('rowsValue').textContent = this.value">
<span id="rowsValue">5</span>
</div>
<div class="preset-buttons">
<button onclick="setBrickPreset(8, 5)">ê¸°ë³¸ (8Ã—5)</button>
<button onclick="setBrickPreset(10, 6)">ë³´í†µ (10Ã—6)</button>
<button onclick="setBrickPreset(12, 8)">ë§ìŒ (12Ã—8)</button>
</div>
</div>

<div class="setting-group">
<label>ğŸ¯ íŒ¨ë“¤ ê¸¸ì´</label>
<div class="setting-row">
<input type="range" id="paddleWidth" min="40" max="120" value="80" step="10"
       oninput="document.getElementById('paddleValue').textContent = this.value + 'px'">
<span id="paddleValue">80px</span>
</div>
<div class="preset-buttons">
<button onclick="setPaddleWidth(60)">ì–´ë ¤ì›€ (60px)</button>
<button onclick="setPaddleWidth(80)">ë³´í†µ (80px)</button>
<button onclick="setPaddleWidth(100)">ì‰¬ì›€ (100px)</button>
</div>
</div>

<div class="setting-group">
<label>âš¡ í•™ìŠµ ì†ë„</label>
<div class="setting-row">
<input type="range" id="speed" min="1" max="10" value="5"
       oninput="document.getElementById('speedValue').textContent = this.value + 'x'">
<span id="speedValue">5x</span>
</div>
</div>

<button onclick="applySettings()" style="width: 100%; background: #FF9800;">âš™ï¸ ì„¤ì • ì ìš© (ê²Œì„ ì´ˆê¸°í™”)</button>
</div>

<div class="game-area">
<canvas id="gameCanvas" width="400" height="500"></canvas>
</div>

<div class="stats">
<div class="stat-box">
<div class="stat-label">ì—í”¼ì†Œë“œ</div>
<div class="stat-value" id="episode">0</div>
</div>
<div class="stat-box">
<div class="stat-label">í˜„ì¬ ì ìˆ˜</div>
<div class="stat-value" id="score">0</div>
</div>
<div class="stat-box">
<div class="stat-label">í‰ê·  ì ìˆ˜</div>
<div class="stat-value" id="avgScore">0</div>
</div>
<div class="stat-box">
<div class="stat-label">ìµœê³  ì ìˆ˜</div>
<div class="stat-value" id="maxScore">0</div>
</div>
<div class="stat-box">
<div class="stat-label">ì„±ê³µë¥ </div>
<div class="stat-value" id="successRate">0%</div>
</div>
<div class="stat-box">
<div class="stat-label">Q-í…Œì´ë¸”</div>
<div class="stat-value" id="qTableSize">0</div>
</div>
</div>

<div class="controls">
<button id="trainBtn" onclick="startTraining()">ğŸ“ í•™ìŠµ ì‹œì‘</button>
<button id="stopBtn" onclick="stopTraining()" disabled>â¸ï¸ ì •ì§€</button>
<button id="resetBtn" onclick="resetLearning()">ğŸ”„ ì´ˆê¸°í™”</button>
<button id="testBtn" onclick="testAgent()">ğŸ¯ í…ŒìŠ¤íŠ¸</button>
<button id="qBtn" onclick="toggleQDisplay()">ğŸ“Š Qê°’</button>
</div>

<div class="q-info">
<strong>ğŸ“ˆ Q-Learning ìƒíƒœ ë‹¨ìˆœí™”:</strong><br>
â€¢ <strong>ìƒíƒœ</strong>: (ê³µ X ìœ„ì¹˜ 10êµ¬ê°„) Ã— (ê³µ ë°©í–¥ 2ê°€ì§€) Ã— (íŒ¨ë“¤ ìœ„ì¹˜ 10êµ¬ê°„) = 200ê°€ì§€<br>
â€¢ <strong>í–‰ë™</strong>: ì™¼ìª½(-1), ì •ì§€(0), ì˜¤ë¥¸ìª½(+1) = 3ê°€ì§€<br>
â€¢ <strong>Q-í…Œì´ë¸” í¬ê¸°</strong>: 200 Ã— 3 = 600ê°œ (ê´€ë¦¬ ê°€ëŠ¥!)<br>
â€¢ <strong>ë³´ìƒ</strong>: ë²½ëŒ ê¹¨ê¸° +10, ê³µ ë°›ê¸° +5, ê³µ ë†“ì¹¨ -100
</div>

<div class="info">
<strong>ğŸ“š í•™ìŠµ ì›ë¦¬:</strong><br>
â€¢ AIê°€ ê³µì˜ ìœ„ì¹˜ì™€ ë°©í–¥ì„ ë³´ê³  íŒ¨ë“¤ì„ ì–´ë””ë¡œ ì›€ì§ì¼ì§€ í•™ìŠµí•©ë‹ˆë‹¤<br>
â€¢ ì²˜ìŒì—” ë¬´ì‘ìœ„ë¡œ ì›€ì§ì´ë‹¤ê°€ ì ì  ê³µì„ ë°›ëŠ” ë²•ì„ ë°°ì›ë‹ˆë‹¤<br>
â€¢ ë²½ëŒì´ ë§ì„ìˆ˜ë¡, íŒ¨ë“¤ì´ ì§§ì„ìˆ˜ë¡ í•™ìŠµì´ ì–´ë µìŠµë‹ˆë‹¤<br>
â€¢ <strong>í•™ìŠµë¥ (Î±)</strong>: 0.3, <strong>í• ì¸ìœ¨(Î³)</strong>: 0.95, <strong>íƒí—˜ìœ¨(Îµ)</strong>: 0.1
</div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ê²Œì„ ì„¤ì • (ë™ì ìœ¼ë¡œ ë³€ê²½ ê°€ëŠ¥)
let PADDLE_WIDTH = 80;
const PADDLE_HEIGHT = 10;
const BALL_RADIUS = 6;
let BRICK_ROWS = 5;
let BRICK_COLS = 8;
let BRICK_WIDTH = 45;
const BRICK_HEIGHT = 15;
const BRICK_PADDING = 5;
const BRICK_OFFSET_TOP = 50;
let BRICK_OFFSET_LEFT = 10;

// Q-Learning ì„¤ì •
const ALPHA = 0.3;
const GAMMA = 0.95;
let EPSILON = 0.1;
const X_ZONES = 10;
const PADDLE_ZONES = 10;
const ACTIONS = [-1, 0, 1];

// ê²Œì„ ìƒíƒœ
let paddle = { x: 0, y: canvas.height - 30, dx: 0 };
let ball = { x: 0, y: 0, dx: 3, dy: -3 };
let bricks = [];
let score = 0;
let lives = 3;

// í•™ìŠµ ìƒíƒœ
let qTable = {};
let episode = 0;
let totalScore = 0;
let maxScore = 0;
let successCount = 0;
let isTraining = false;
let showQ = false;
let gameInterval = null;

function setBrickPreset(cols, rows) {
document.getElementById('brickCols').value = cols;
document.getElementById('brickRows').value = rows;
document.getElementById('colsValue').textContent = cols;
document.getElementById('rowsValue').textContent = rows;
}

function setPaddleWidth(width) {
document.getElementById('paddleWidth').value = width;
document.getElementById('paddleValue').textContent = width + 'px';
}

function applySettings() {
stopTraining();

BRICK_COLS = parseInt(document.getElementById('brickCols').value);
BRICK_ROWS = parseInt(document.getElementById('brickRows').value);
PADDLE_WIDTH = parseInt(document.getElementById('paddleWidth').value);

// ë²½ëŒ í¬ê¸° ì¬ê³„ì‚°
const totalBrickWidth = canvas.width - 20;
BRICK_WIDTH = (totalBrickWidth - (BRICK_COLS - 1) * BRICK_PADDING) / BRICK_COLS;
BRICK_OFFSET_LEFT = 10;

resetLearning();
alert(`ì„¤ì •ì´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤!
ë²½ëŒ: ${BRICK_COLS}Ã—${BRICK_ROWS}
íŒ¨ë“¤ ê¸¸ì´: ${PADDLE_WIDTH}px`);
}

function initBricks() {
bricks = [];
for (let row = 0; row < BRICK_ROWS; row++) {
bricks[row] = [];
for (let col = 0; col < BRICK_COLS; col++) {
bricks[row][col] = { x: 0, y: 0, status: 1 };
}
}
}

function getStateKey(ballX, ballDX, paddleX) {
const ballZone = Math.floor(ballX / (canvas.width / X_ZONES));
const ballDir = ballDX > 0 ? 1 : 0;
const paddleZone = Math.floor(paddleX / (canvas.width / PADDLE_ZONES));
return `${ballZone}-${ballDir}-${paddleZone}`;
}

function getQValue(state, action) {
const key = `${state}-${action}`;
return qTable[key] || 0;
}

function setQValue(state, action, value) {
const key = `${state}-${action}`;
qTable[key] = value;
}

function chooseAction(state) {
if (Math.random() < EPSILON) {
return ACTIONS[Math.floor(Math.random() * ACTIONS.length)];
}

let bestAction = ACTIONS[0];
let bestValue = getQValue(state, bestAction);

for (let action of ACTIONS) {
const value = getQValue(state, action);
if (value > bestValue) {
bestValue = value;
bestAction = action;
}
}
return bestAction;
}

function updateQValue(state, action, reward, nextState) {
const currentQ = getQValue(state, action);

let maxNextQ = -Infinity;
for (let nextAction of ACTIONS) {
const q = getQValue(nextState, nextAction);
if (q > maxNextQ) maxNextQ = q;
}

const newQ = currentQ + ALPHA * (reward + GAMMA * maxNextQ - currentQ);
setQValue(state, action, newQ);
}

function drawBricks() {
for (let row = 0; row < BRICK_ROWS; row++) {
for (let col = 0; col < BRICK_COLS; col++) {
if (bricks[row][col].status === 1) {
const brickX = col * (BRICK_WIDTH + BRICK_PADDING) + BRICK_OFFSET_LEFT;
const brickY = row * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_OFFSET_TOP;
bricks[row][col].x = brickX;
bricks[row][col].y = brickY;

ctx.fillStyle = '#4CAF50';
ctx.fillRect(brickX, brickY, BRICK_WIDTH, BRICK_HEIGHT);
ctx.strokeStyle = '#fff';
ctx.strokeRect(brickX, brickY, BRICK_WIDTH, BRICK_HEIGHT);
}
}
}
}

function drawPaddle() {
ctx.fillStyle = '#2196F3';
ctx.fillRect(paddle.x, paddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);
}

function drawBall() {
ctx.beginPath();
ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI * 2);
ctx.fillStyle = '#FFD700';
ctx.fill();
ctx.closePath();
}

function drawQValues() {
if (!showQ) return;

const state = getStateKey(ball.x, ball.dx, paddle.x);
const qLeft = getQValue(state, -1);
const qStay = getQValue(state, 0);
const qRight = getQValue(state, 1);

ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
ctx.fillRect(10, canvas.height - 80, 150, 70);
ctx.fillStyle = '#333';
ctx.font = '12px Arial';
ctx.fillText(`Qê°’ (í˜„ì¬ ìƒíƒœ):`, 20, canvas.height - 65);
ctx.fillText(`â† ì™¼ìª½: ${qLeft.toFixed(1)}`, 20, canvas.height - 50);
ctx.fillText(`â–  ì •ì§€: ${qStay.toFixed(1)}`, 20, canvas.height - 35);
ctx.fillText(`â†’ ì˜¤ë¥¸ìª½: ${qRight.toFixed(1)}`, 20, canvas.height - 20);
}

function collisionDetection() {
let reward = -0.1;

for (let row = 0; row < BRICK_ROWS; row++) {
for (let col = 0; col < BRICK_COLS; col++) {
const brick = bricks[row][col];
if (brick.status === 1) {
if (ball.x > brick.x && ball.x < brick.x + BRICK_WIDTH &&
ball.y > brick.y && ball.y < brick.y + BRICK_HEIGHT) {
ball.dy = -ball.dy;
brick.status = 0;
score += 10;
reward += 10;
}
}
}
}

return reward;
}

function draw() {
ctx.fillStyle = '#000';
ctx.fillRect(0, 0, canvas.width, canvas.height);

drawBricks();
drawPaddle();
drawBall();
drawQValues();

ctx.fillStyle = '#fff';
ctx.font = '16px Arial';
ctx.fillText(`ì ìˆ˜: ${score}`, 10, 20);
ctx.fillText(`ì—í”¼ì†Œë“œ: ${episode}`, 10, 40);
}

function update() {
const state = getStateKey(ball.x, ball.dx, paddle.x);
const action = chooseAction(state);

paddle.dx = action * 8;
paddle.x += paddle.dx;

if (paddle.x < 0) paddle.x = 0;
if (paddle.x + PADDLE_WIDTH > canvas.width) paddle.x = canvas.width - PADDLE_WIDTH;

ball.x += ball.dx;
ball.y += ball.dy;

if (ball.x + BALL_RADIUS > canvas.width || ball.x - BALL_RADIUS < 0) {
ball.dx = -ball.dx;
}
if (ball.y - BALL_RADIUS < 0) {
ball.dy = -ball.dy;
}

let reward = collisionDetection();

if (ball.y + BALL_RADIUS > paddle.y && 
ball.x > paddle.x && 
ball.x < paddle.x + PADDLE_WIDTH &&
ball.dy > 0) {
ball.dy = -ball.dy;
reward += 5;
}

if (ball.y + BALL_RADIUS > canvas.height) {
reward = -100;
const nextState = getStateKey(ball.x, ball.dx, paddle.x);
updateQValue(state, action, reward, nextState);

lives--;
if (lives <= 0) {
endEpisode();
return false;
}
resetBall();
return true;
}

if (bricks.every(row => row.every(brick => brick.status === 0))) {
reward += 100;
successCount++;
const nextState = getStateKey(ball.x, ball.dx, paddle.x);
updateQValue(state, action, reward, nextState);
endEpisode();
return false;
}

const nextState = getStateKey(ball.x, ball.dx, paddle.x);
updateQValue(state, action, reward, nextState);

return true;
}

function resetBall() {
ball.x = canvas.width / 2;
ball.y = canvas.height - 50;
ball.dx = (Math.random() > 0.5 ? 1 : -1) * 3;
ball.dy = -3;
}

function gameLoop() {
draw();
if (isTraining) {
const speed = parseInt(document.getElementById('speed').value);
for (let i = 0; i < speed; i++) {
if (!update()) break;
}
updateStats();
}
}

function endEpisode() {
episode++;
totalScore += score;
maxScore = Math.max(maxScore, score);
updateStats();

if (isTraining) {
setTimeout(() => {
initGame();
}, 200);
}
}

function initGame() {
initBricks();
paddle.x = canvas.width / 2 - PADDLE_WIDTH / 2;
resetBall();
score = 0;
lives = 3;
}

function updateStats() {
document.getElementById('episode').textContent = episode;
document.getElementById('score').textContent = score;
document.getElementById('avgScore').textContent = episode > 0 ? Math.round(totalScore / episode) : 0;
document.getElementById('maxScore').textContent = maxScore;
const successRate = episode > 0 ? Math.round((successCount / episode) * 100) : 0;
document.getElementById('successRate').textContent = successRate + '%';
document.getElementById('qTableSize').textContent = Object.keys(qTable).length;
}

function startTraining() {
isTraining = true;
EPSILON = 0.1;
document.getElementById('trainBtn').disabled = true;
document.getElementById('stopBtn').disabled = false;
document.getElementById('testBtn').disabled = true;

if (!gameInterval) {
initGame();
gameInterval = setInterval(gameLoop, 1000 / 60);
}
}

function stopTraining() {
isTraining = false;
document.getElementById('trainBtn').disabled = false;
document.getElementById('stopBtn').disabled = true;
document.getElementById('testBtn').disabled = false;
}

function resetLearning() {
stopTraining();
qTable = {};
episode = 0;
totalScore = 0;
maxScore = 0;
successCount = 0;
initGame();
updateStats();
}

function testAgent() {
stopTraining();
EPSILON = 0;
isTraining = true;
document.getElementById('trainBtn').disabled = true;
document.getElementById('testBtn').disabled = true;

if (!gameInterval) {
initGame();
gameInterval = setInterval(gameLoop, 1000 / 60);
}

setTimeout(() => {
isTraining = false;
EPSILON = 0.1;
document.getElementById('trainBtn').disabled = false;
document.getElementById('testBtn').disabled = false;
}, 30000);
}

function toggleQDisplay() {
showQ = !showQ;
const btn = document.getElementById('qBtn');
if (showQ) {
btn.classList.add('active');
btn.textContent = 'ğŸ“Š Qê°’âœ“';
} else {
btn.classList.remove('active');
btn.textContent = 'ğŸ“Š Qê°’';
}
}

initGame();
updateStats();
</script>
</body>
</html>
